import Head from 'next/head'
import React, { useEffect, useState } from 'react'
import Layout from '../../components/layout'
import styles from '../../styles/Home.module.scss'
import useTranslation from 'next-translate/useTranslation'
import ProductList from '../../components/product-list'
import SearchProducts from '../../components/search-products'
import { http } from '../../utils/http'
import { Product } from '../../models/Product'

const perpage = 4
const baseURL = `/api/v1/products/get-all-products?paginate=1&perpage=${perpage}`

interface ICurrentURL {
  url: string
  isSearch: boolean
}

export default function Categories() {
  const { t, lang } = useTranslation('common')
  const [products, setProducts] = useState<Product[]>([])
  const [paginationInfo, setPaginationInfo] = useState<any>()
  const [currentURL, setCurrentURL] = useState<ICurrentURL>({
    url: baseURL,
    isSearch: false,
  })

  useEffect(() => {
    async function fetchProducts() {
      try {
        const response = await loadMoreProducts(currentURL.url, false)
        const { items } = response.data?.data || []
        const paginationInfo = response.data?.data?.pagination
        if (items?.length > 0) {
          const products = mapProductPropertiesToCamelCase(items)
          setProducts(products)
          setPaginationInfo(paginationInfo)
        }
      } catch (error) {
        console.error(error)
      }
    }
    fetchProducts()
  }, [lang, currentURL])

  // default function to fetch products, made it separate to handle pagination and avoid conflicts on language switching
  const loadMoreProducts = async (url: string, isPaginatedRequest: boolean) => {
    const response = await http.get(`${url}`, {
      headers: {
        'Content-Language': lang,
      },
    })

    if (isPaginatedRequest) {
      const { items } = response.data?.data || []
      const paginationInfo = response.data?.data?.pagination
      if (items?.length > 0) {
        const products = mapProductPropertiesToCamelCase(items)
        setProducts(prevState => [...prevState, ...products])
        setPaginationInfo(paginationInfo)
      }
    }

    return response
  }

  const mapProductPropertiesToCamelCase = (items: Product[]) => {
    const products = items.map((item: any) => {
      return {
        ...item,
        productsTitle: item.products_title,
        productsShortDescription: item.products_short_description,
        productsDescription: item.products_description,
        productsAdditionalInfo: item.products_additional_info,
        productsCategoryId: item.products_category_id,
        productsFeaturedImage: item.products_featured_image,
      }
    })
    return products
  }

  const searchProducts = (searchText: string, withSearch: boolean) => {
    if (withSearch) {
      setCurrentURL({
        url: `${baseURL}&search=${searchText}`,
        isSearch: true,
      })
    } else {
      setCurrentURL({
        url: baseURL,
        isSearch: true,
      })
    }
  }

  return (
    <div className={styles.container}>
      <Head>
        <title>{`Winmed - ${t('categories')}`}</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>
      <Layout>
        <SearchProducts
          searchProducts={(searchText: string, withSearch: boolean) =>
            searchProducts(searchText, withSearch)
          }
        />
        <ProductList
          products={products}
          paginationInfo={paginationInfo}
          loadMoreProducts={(url: string, isPaginateRequest: boolean) =>
            loadMoreProducts(url, isPaginateRequest)
          }
        />
      </Layout>
    </div>
  )
}
